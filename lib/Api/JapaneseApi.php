<?php
/**
 * JapaneseApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NamSor API v2
 *
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!
 *
 * OpenAPI spec version: 2.0.10
 * Contact: contact@namsor.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * JapaneseApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class JapaneseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation genderJapaneseNameFull
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PersonalNameGenderedOut
     */
    public function genderJapaneseNameFull($japanese_name)
    {
        list($response) = $this->genderJapaneseNameFullWithHttpInfo($japanese_name);
        return $response;
    }

    /**
     * Operation genderJapaneseNameFullWithHttpInfo
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNameFullWithHttpInfo($japanese_name)
    {
        $request = $this->genderJapaneseNameFullRequest($japanese_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PersonalNameGenderedOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNameFullAsync
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullAsync($japanese_name)
    {
        return $this->genderJapaneseNameFullAsyncWithHttpInfo($japanese_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNameFullAsyncWithHttpInfo
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullAsyncWithHttpInfo($japanese_name)
    {
        $returnType = '\OpenAPI\Client\Model\PersonalNameGenderedOut';
        $request = $this->genderJapaneseNameFullRequest($japanese_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNameFull'
     *
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function genderJapaneseNameFullRequest($japanese_name)
    {
        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling genderJapaneseNameFull'
            );
        }

        $resourcePath = '/api2/json/genderJapaneseNameFull/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderJapaneseNameFullBatch
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchPersonalNameGenderedOut
     */
    public function genderJapaneseNameFullBatch($batch_personal_name_in = null)
    {
        list($response) = $this->genderJapaneseNameFullBatchWithHttpInfo($batch_personal_name_in);
        return $response;
    }

    /**
     * Operation genderJapaneseNameFullBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchPersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNameFullBatchWithHttpInfo($batch_personal_name_in = null)
    {
        $request = $this->genderJapaneseNameFullBatchRequest($batch_personal_name_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchPersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchPersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchPersonalNameGenderedOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchPersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNameFullBatchAsync
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullBatchAsync($batch_personal_name_in = null)
    {
        return $this->genderJapaneseNameFullBatchAsyncWithHttpInfo($batch_personal_name_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNameFullBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullBatchAsyncWithHttpInfo($batch_personal_name_in = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchPersonalNameGenderedOut';
        $request = $this->genderJapaneseNameFullBatchRequest($batch_personal_name_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNameFullBatch'
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function genderJapaneseNameFullBatchRequest($batch_personal_name_in = null)
    {

        $resourcePath = '/api2/json/genderJapaneseNameFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch_personal_name_in)) {
            $_tempBody = $batch_personal_name_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderJapaneseNamePinyin
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname japanese_surname (required)
     * @param  string $japanese_given_name japanese_given_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FirstLastNameGenderedOut
     */
    public function genderJapaneseNamePinyin($japanese_surname, $japanese_given_name)
    {
        list($response) = $this->genderJapaneseNamePinyinWithHttpInfo($japanese_surname, $japanese_given_name);
        return $response;
    }

    /**
     * Operation genderJapaneseNamePinyinWithHttpInfo
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNamePinyinWithHttpInfo($japanese_surname, $japanese_given_name)
    {
        $request = $this->genderJapaneseNamePinyinRequest($japanese_surname, $japanese_given_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FirstLastNameGenderedOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNamePinyinAsync
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinAsync($japanese_surname, $japanese_given_name)
    {
        return $this->genderJapaneseNamePinyinAsyncWithHttpInfo($japanese_surname, $japanese_given_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNamePinyinAsyncWithHttpInfo
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinAsyncWithHttpInfo($japanese_surname, $japanese_given_name)
    {
        $returnType = '\OpenAPI\Client\Model\FirstLastNameGenderedOut';
        $request = $this->genderJapaneseNamePinyinRequest($japanese_surname, $japanese_given_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNamePinyin'
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function genderJapaneseNamePinyinRequest($japanese_surname, $japanese_given_name)
    {
        // verify the required parameter 'japanese_surname' is set
        if ($japanese_surname === null || (is_array($japanese_surname) && count($japanese_surname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname when calling genderJapaneseNamePinyin'
            );
        }
        // verify the required parameter 'japanese_given_name' is set
        if ($japanese_given_name === null || (is_array($japanese_given_name) && count($japanese_given_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name when calling genderJapaneseNamePinyin'
            );
        }

        $resourcePath = '/api2/json/genderJapaneseName/{japaneseSurname}/{japaneseGivenName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_surname !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurname' . '}',
                ObjectSerializer::toPathValue($japanese_surname),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenName' . '}',
                ObjectSerializer::toPathValue($japanese_given_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderJapaneseNamePinyinBatch
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of names, with country code. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchFirstLastNameGenderedOut
     */
    public function genderJapaneseNamePinyinBatch($batch_first_last_name_in = null)
    {
        list($response) = $this->genderJapaneseNamePinyinBatchWithHttpInfo($batch_first_last_name_in);
        return $response;
    }

    /**
     * Operation genderJapaneseNamePinyinBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of names, with country code. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchFirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNamePinyinBatchWithHttpInfo($batch_first_last_name_in = null)
    {
        $request = $this->genderJapaneseNamePinyinBatchRequest($batch_first_last_name_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchFirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchFirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchFirstLastNameGenderedOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchFirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNamePinyinBatchAsync
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of names, with country code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinBatchAsync($batch_first_last_name_in = null)
    {
        return $this->genderJapaneseNamePinyinBatchAsyncWithHttpInfo($batch_first_last_name_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNamePinyinBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of names, with country code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinBatchAsyncWithHttpInfo($batch_first_last_name_in = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchFirstLastNameGenderedOut';
        $request = $this->genderJapaneseNamePinyinBatchRequest($batch_first_last_name_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNamePinyinBatch'
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of names, with country code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function genderJapaneseNamePinyinBatchRequest($batch_first_last_name_in = null)
    {

        $resourcePath = '/api2/json/genderJapaneseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch_first_last_name_in)) {
            $_tempBody = $batch_first_last_name_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameKanjiCandidates
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RomanizedNameOut
     */
    public function japaneseNameKanjiCandidates($japanese_surname_latin, $japanese_given_name_latin)
    {
        list($response) = $this->japaneseNameKanjiCandidatesWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin);
        return $response;
    }

    /**
     * Operation japaneseNameKanjiCandidatesWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RomanizedNameOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameKanjiCandidatesWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin)
    {
        $request = $this->japaneseNameKanjiCandidatesRequest($japanese_surname_latin, $japanese_given_name_latin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RomanizedNameOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RomanizedNameOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RomanizedNameOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameKanjiCandidatesAsync
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesAsync($japanese_surname_latin, $japanese_given_name_latin)
    {
        return $this->japaneseNameKanjiCandidatesAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameKanjiCandidatesAsyncWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin)
    {
        $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
        $request = $this->japaneseNameKanjiCandidatesRequest($japanese_surname_latin, $japanese_given_name_latin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameKanjiCandidates'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameKanjiCandidatesRequest($japanese_surname_latin, $japanese_given_name_latin)
    {
        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameKanjiCandidates'
            );
        }
        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameKanjiCandidates'
            );
        }

        $resourcePath = '/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatch
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName = japaneseGivenName; lastName=japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchNameMatchCandidatesOut
     */
    public function japaneseNameKanjiCandidatesBatch($batch_first_last_name_in = null)
    {
        list($response) = $this->japaneseNameKanjiCandidatesBatchWithHttpInfo($batch_first_last_name_in);
        return $response;
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatchWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName = japaneseGivenName; lastName=japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameKanjiCandidatesBatchWithHttpInfo($batch_first_last_name_in = null)
    {
        $request = $this->japaneseNameKanjiCandidatesBatchRequest($batch_first_last_name_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatchAsync
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName = japaneseGivenName; lastName=japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesBatchAsync($batch_first_last_name_in = null)
    {
        return $this->japaneseNameKanjiCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatchAsyncWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName = japaneseGivenName; lastName=japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->japaneseNameKanjiCandidatesBatchRequest($batch_first_last_name_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameKanjiCandidatesBatch'
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameKanjiCandidatesBatchRequest($batch_first_last_name_in = null)
    {

        $resourcePath = '/api2/json/japaneseNameKanjiCandidatesBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch_first_last_name_in)) {
            $_tempBody = $batch_first_last_name_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameLatinCandidates
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji japanese_given_name_kanji (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RomanizedNameOut
     */
    public function japaneseNameLatinCandidates($japanese_surname_kanji, $japanese_given_name_kanji)
    {
        list($response) = $this->japaneseNameLatinCandidatesWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji);
        return $response;
    }

    /**
     * Operation japaneseNameLatinCandidatesWithHttpInfo
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RomanizedNameOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameLatinCandidatesWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji)
    {
        $request = $this->japaneseNameLatinCandidatesRequest($japanese_surname_kanji, $japanese_given_name_kanji);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RomanizedNameOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RomanizedNameOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RomanizedNameOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameLatinCandidatesAsync
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesAsync($japanese_surname_kanji, $japanese_given_name_kanji)
    {
        return $this->japaneseNameLatinCandidatesAsyncWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameLatinCandidatesAsyncWithHttpInfo
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesAsyncWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji)
    {
        $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
        $request = $this->japaneseNameLatinCandidatesRequest($japanese_surname_kanji, $japanese_given_name_kanji);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameLatinCandidates'
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameLatinCandidatesRequest($japanese_surname_kanji, $japanese_given_name_kanji)
    {
        // verify the required parameter 'japanese_surname_kanji' is set
        if ($japanese_surname_kanji === null || (is_array($japanese_surname_kanji) && count($japanese_surname_kanji) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_kanji when calling japaneseNameLatinCandidates'
            );
        }
        // verify the required parameter 'japanese_given_name_kanji' is set
        if ($japanese_given_name_kanji === null || (is_array($japanese_given_name_kanji) && count($japanese_given_name_kanji) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_kanji when calling japaneseNameLatinCandidates'
            );
        }

        $resourcePath = '/api2/json/japaneseNameLatinCandidates/{japaneseSurnameKanji}/{japaneseGivenNameKanji}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_surname_kanji !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameKanji' . '}',
                ObjectSerializer::toPathValue($japanese_surname_kanji),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_kanji !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameKanji' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_kanji),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameLatinCandidatesBatch
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchNameMatchCandidatesOut
     */
    public function japaneseNameLatinCandidatesBatch($batch_first_last_name_in = null)
    {
        list($response) = $this->japaneseNameLatinCandidatesBatchWithHttpInfo($batch_first_last_name_in);
        return $response;
    }

    /**
     * Operation japaneseNameLatinCandidatesBatchWithHttpInfo
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameLatinCandidatesBatchWithHttpInfo($batch_first_last_name_in = null)
    {
        $request = $this->japaneseNameLatinCandidatesBatchRequest($batch_first_last_name_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameLatinCandidatesBatchAsync
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesBatchAsync($batch_first_last_name_in = null)
    {
        return $this->japaneseNameLatinCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameLatinCandidatesBatchAsyncWithHttpInfo
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->japaneseNameLatinCandidatesBatchRequest($batch_first_last_name_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameLatinCandidatesBatch'
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameLatinCandidatesBatchRequest($batch_first_last_name_in = null)
    {

        $resourcePath = '/api2/json/japaneseNameLatinCandidatesBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch_first_last_name_in)) {
            $_tempBody = $batch_first_last_name_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameMatch
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     * @param  string $japanese_name japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RomanizedNameOut
     */
    public function japaneseNameMatch($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        list($response) = $this->japaneseNameMatchWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name);
        return $response;
    }

    /**
     * Operation japaneseNameMatchWithHttpInfo
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RomanizedNameOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameMatchWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        $request = $this->japaneseNameMatchRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RomanizedNameOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RomanizedNameOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RomanizedNameOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameMatchAsync
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchAsync($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        return $this->japaneseNameMatchAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameMatchAsyncWithHttpInfo
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
        $request = $this->japaneseNameMatchRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameMatch'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameMatchRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameMatch'
            );
        }
        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameMatch'
            );
        }
        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling japaneseNameMatch'
            );
        }

        $resourcePath = '/api2/json/japaneseNameMatch/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameMatchBatch
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchNameMatchCandidatesOut
     */
    public function japaneseNameMatchBatch($batch_first_last_name_in = null)
    {
        list($response) = $this->japaneseNameMatchBatchWithHttpInfo($batch_first_last_name_in);
        return $response;
    }

    /**
     * Operation japaneseNameMatchBatchWithHttpInfo
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameMatchBatchWithHttpInfo($batch_first_last_name_in = null)
    {
        $request = $this->japaneseNameMatchBatchRequest($batch_first_last_name_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameMatchBatchAsync
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchBatchAsync($batch_first_last_name_in = null)
    {
        return $this->japaneseNameMatchBatchAsyncWithHttpInfo($batch_first_last_name_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameMatchBatchAsyncWithHttpInfo
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchBatchAsyncWithHttpInfo($batch_first_last_name_in = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->japaneseNameMatchBatchRequest($batch_first_last_name_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameMatchBatch'
     *
     * @param  \OpenAPI\Client\Model\BatchFirstLastNameIn $batch_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameMatchBatchRequest($batch_first_last_name_in = null)
    {

        $resourcePath = '/api2/json/japaneseNameMatchBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch_first_last_name_in)) {
            $_tempBody = $batch_first_last_name_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameMatchFeedbackLoop
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     * @param  string $japanese_name japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RomanizedNameOut
     */
    public function japaneseNameMatchFeedbackLoop($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        list($response) = $this->japaneseNameMatchFeedbackLoopWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name);
        return $response;
    }

    /**
     * Operation japaneseNameMatchFeedbackLoopWithHttpInfo
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RomanizedNameOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameMatchFeedbackLoopWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        $request = $this->japaneseNameMatchFeedbackLoopRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RomanizedNameOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RomanizedNameOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RomanizedNameOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameMatchFeedbackLoopAsync
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchFeedbackLoopAsync($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        return $this->japaneseNameMatchFeedbackLoopAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameMatchFeedbackLoopAsyncWithHttpInfo
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchFeedbackLoopAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        $returnType = '\OpenAPI\Client\Model\RomanizedNameOut';
        $request = $this->japaneseNameMatchFeedbackLoopRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameMatchFeedbackLoop'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function japaneseNameMatchFeedbackLoopRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name)
    {
        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameMatchFeedbackLoop'
            );
        }
        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameMatchFeedbackLoop'
            );
        }
        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling japaneseNameMatchFeedbackLoop'
            );
        }

        $resourcePath = '/api2/json/japaneseNameMatchFeedbackLoop/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseJapaneseName
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PersonalNameParsedOut
     */
    public function parseJapaneseName($japanese_name)
    {
        list($response) = $this->parseJapaneseNameWithHttpInfo($japanese_name);
        return $response;
    }

    /**
     * Operation parseJapaneseNameWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseJapaneseNameWithHttpInfo($japanese_name)
    {
        $request = $this->parseJapaneseNameRequest($japanese_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PersonalNameParsedOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PersonalNameParsedOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseJapaneseNameAsync
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameAsync($japanese_name)
    {
        return $this->parseJapaneseNameAsyncWithHttpInfo($japanese_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseJapaneseNameAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameAsyncWithHttpInfo($japanese_name)
    {
        $returnType = '\OpenAPI\Client\Model\PersonalNameParsedOut';
        $request = $this->parseJapaneseNameRequest($japanese_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseJapaneseName'
     *
     * @param  string $japanese_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function parseJapaneseNameRequest($japanese_name)
    {
        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling parseJapaneseName'
            );
        }

        $resourcePath = '/api2/json/parseJapaneseName/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseJapaneseNameBatch
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchPersonalNameParsedOut
     */
    public function parseJapaneseNameBatch($batch_personal_name_in = null)
    {
        list($response) = $this->parseJapaneseNameBatchWithHttpInfo($batch_personal_name_in);
        return $response;
    }

    /**
     * Operation parseJapaneseNameBatchWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchPersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseJapaneseNameBatchWithHttpInfo($batch_personal_name_in = null)
    {
        $request = $this->parseJapaneseNameBatchRequest($batch_personal_name_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchPersonalNameParsedOut' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchPersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchPersonalNameParsedOut';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchPersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseJapaneseNameBatchAsync
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameBatchAsync($batch_personal_name_in = null)
    {
        return $this->parseJapaneseNameBatchAsyncWithHttpInfo($batch_personal_name_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseJapaneseNameBatchAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameBatchAsyncWithHttpInfo($batch_personal_name_in = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchPersonalNameParsedOut';
        $request = $this->parseJapaneseNameBatchRequest($batch_personal_name_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseJapaneseNameBatch'
     *
     * @param  \OpenAPI\Client\Model\BatchPersonalNameIn $batch_personal_name_in A list of personal names (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function parseJapaneseNameBatchRequest($batch_personal_name_in = null)
    {

        $resourcePath = '/api2/json/parseJapaneseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batch_personal_name_in)) {
            $_tempBody = $batch_personal_name_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
